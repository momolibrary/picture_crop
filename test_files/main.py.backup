"""
å›¾ç‰‡æ¢¯å½¢è£å‰ªæ ¡æ­£å·¥å…· - API æœåŠ¡
åŸºäº FastAPI çš„çº¯ API å›¾åƒå¤„ç†æœåŠ¡ï¼Œæ”¯æŒæ¢¯å½¢å›¾ç‰‡çš„é€è§†æ ¡æ­£å’Œè£å‰?
ä¸ºç°ä»£å‰ç«¯åº”ç”¨æä¾›å®Œæ•´çš„ REST API æ¥å£
"""
import os
import cv2
import shutil
import time
import uvicorn
import urllib.parse
from typing import List, Optional
from pydantic import BaseModel
from fastapi import FastAPI, UploadFile, HTTPException, File
from fastapi.responses import FileResponse, Response
from fastapi.middleware.cors import CORSMiddleware

# å¯¼å…¥è‡ªå®šä¹‰æ¨¡å?
from image_processor import (
    four_point_transform, 
    validate_and_correct_points, 
    resize_image_for_preview, 
    encode_image_to_jpeg,
    auto_detect_corners,
    generate_thumbnail,
    get_thumbnail_path
)

# åˆ›å»º FastAPI åº”ç”¨
app = FastAPI(
    title="å›¾ç‰‡æ¢¯å½¢è£å‰ªæ ¡æ­£ API",
    description="ä¸ºå›¾ç‰‡æ¢¯å½¢è£å‰ªæ ¡æ­£å·¥å…·æä¾›çš„å®Œæ•´ REST API æ¥å£",
    version="2.0.0"
)

# æ·»åŠ  CORS ä¸­é—´ä»?
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000", "*"],  # å…è®¸å‰ç«¯å¼€å‘æœåŠ¡å™¨
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# é…ç½®æ–‡ä»¶å¤?
SOURCE_DIR = "source_images"
OUTPUT_DIR = "output_images"
PROCESSED_DIR = "processed"
THUMBNAIL_DIR = "thumbnails"

# ç¡®ä¿ç›®å½•å­˜åœ¨
os.makedirs(SOURCE_DIR, exist_ok=True)
os.makedirs(OUTPUT_DIR, exist_ok=True)
os.makedirs(PROCESSED_DIR, exist_ok=True)
os.makedirs(THUMBNAIL_DIR, exist_ok=True)

# API æ•°æ®æ¨¡å‹å®šä¹‰
class ImageInfo(BaseModel):
    """å›¾ç‰‡ä¿¡æ¯æ¨¡å‹"""
    filename: str
    width: int
    height: int
    file_size: Optional[int] = None
    created_time: Optional[str] = None
    has_thumbnail: bool = False
    thumbnail_url: Optional[str] = None

class PaginatedFileListResponse(BaseModel):
    """åˆ†é¡µæ–‡ä»¶åˆ—è¡¨å“åº”æ¨¡å‹"""
    pending_files: List[ImageInfo]
    processed_files: List[str]
    total_files: int
    completion_rate: float
    page: int
    page_size: int
    total_pages: int
    has_next: bool
    has_prev: bool

class FileListResponse(BaseModel):
    """æ–‡ä»¶åˆ—è¡¨å“åº”æ¨¡å‹ - ä¿æŒå‘åå…¼å®¹"""
    pending_files: List[ImageInfo]
    processed_files: List[str]
    total_files: int
    completion_rate: float

class CropRequest(BaseModel):
    """è£å‰ªè¯·æ±‚æ¨¡å‹"""
    points: List[List[float]]  # å››ä¸ªè§’ç‚¹åæ ‡ [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]

class CropResponse(BaseModel):
    """è£å‰ªå“åº”æ¨¡å‹"""
    success: bool
    filename: Optional[str] = None
    message: str
    processed_filename: Optional[str] = None
    error: Optional[str] = None

class AutoDetectResponse(BaseModel):
    """è‡ªåŠ¨æ£€æµ‹å“åº”æ¨¡å?""
    success: bool
    corners: Optional[List[List[float]]] = None
    confidence: float
    message: str
    error: Optional[str] = None

class NextFileResponse(BaseModel):
    """ä¸‹ä¸€ä¸ªæ–‡ä»¶å“åº”æ¨¡å?""
    success: bool
    next_filename: Optional[str] = None
    remaining_count: int
    message: str

@app.get("/")
async def root():
    """æ ¹è·¯å¾?- é‡å®šå‘åˆ° API æ–‡æ¡£"""
    return {
        "message": "å›¾ç‰‡æ¢¯å½¢è£å‰ªæ ¡æ­£ API",
        "version": "2.0.0",
        "docs": "/docs",
        "redoc": "/redoc",
        "status": "active"
    }

@app.get("/api/health")
async def health_check():
    """å¥åº·æ£€æŸ¥ç«¯ç‚?""
    return {
        "status": "healthy",
        "timestamp": time.time(),
        "directories": {
            "source": os.path.exists(SOURCE_DIR),
            "output": os.path.exists(OUTPUT_DIR),
            "processed": os.path.exists(PROCESSED_DIR)
        }
    }

# è¾…åŠ©å‡½æ•°
def generate_thumbnail_if_needed(image_path: str, filename: str) -> tuple[bool, str]:
    """
    å¦‚æœéœ€è¦ï¼Œç”Ÿæˆç¼©ç•¥å›?
    
    Returns:
        tuple: (has_thumbnail, thumbnail_url)
    """
    thumbnail_path = get_thumbnail_path(filename, THUMBNAIL_DIR)
    
    # æ£€æŸ¥ç¼©ç•¥å›¾æ˜¯å¦å·²å­˜åœ¨ä¸”æ¯”åŸå›¾æ–°
    if os.path.exists(thumbnail_path):
        thumb_mtime = os.path.getmtime(thumbnail_path)
        img_mtime = os.path.getmtime(image_path)
        if thumb_mtime >= img_mtime:
            return True, f"/api/thumbnail/{filename}"
    
    # ç”Ÿæˆç¼©ç•¥å›?
    if generate_thumbnail(image_path, thumbnail_path):
        return True, f"/api/thumbnail/{filename}"
    
    return False, ""

# API å®ç°éƒ¨åˆ†
@app.get("/api/files/paginated", response_model=PaginatedFileListResponse)
async def get_files_paginated(page: int = 1, page_size: int = 20):
    """è·å–åˆ†é¡µæ–‡ä»¶åˆ—è¡¨ - ä¼˜åŒ–æ€§èƒ½çš„æ–°æ¥å£"""
    try:
        # è·å–å¾…å¤„ç†æ–‡ä»?
        all_files = [f for f in os.listdir(SOURCE_DIR) if f.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp'))]
        all_files.sort(key=lambda f: os.path.getctime(os.path.join(SOURCE_DIR, f)), reverse=True)
        
        # è®¡ç®—åˆ†é¡µ
        total_files = len(all_files)
        total_pages = (total_files + page_size - 1) // page_size
        start_idx = (page - 1) * page_size
        end_idx = start_idx + page_size
        page_files = all_files[start_idx:end_idx]
        
        pending_files = []
        
        for filename in page_files:
            path = os.path.join(SOURCE_DIR, filename)
            if os.path.exists(path):
                try:
                    img = cv2.imread(path)
                    if img is not None:
                        height, width = img.shape[:2]
                        file_size = os.path.getsize(path)
                        created_time = time.ctime(os.path.getctime(path))
                        
                        # ç”Ÿæˆç¼©ç•¥å›?
                        has_thumbnail, thumbnail_url = generate_thumbnail_if_needed(path, filename)
                        
                        pending_files.append(ImageInfo(
                            filename=filename,
                            width=int(width),
                            height=int(height),
                            file_size=file_size,
                            created_time=created_time,
                            has_thumbnail=has_thumbnail,
                            thumbnail_url=thumbnail_url
                        ))
                except Exception as e:
                    print(f"Error processing file {filename}: {e}")
                    continue
        
        # è·å–å·²å¤„ç†æ–‡ä»?
        processed_files = [f for f in os.listdir(PROCESSED_DIR) if f.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp'))]
        
        # è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        total_all_files = len(all_files) + len(processed_files)
        completion_rate = (len(processed_files) / total_all_files * 100) if total_all_files > 0 else 100
        
        return PaginatedFileListResponse(
            pending_files=pending_files,
            processed_files=processed_files,
            total_files=total_all_files,
            completion_rate=completion_rate,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
            has_next=page < total_pages,
            has_prev=page > 1
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥: {str(e)}")

@app.get("/api/files", response_model=FileListResponse)
async def get_files():
    """è·å–æ–‡ä»¶åˆ—è¡¨ - å…¼å®¹æ—§æ¥å£ï¼Œä½†ä¼˜åŒ–ä¸ºåªè¿”å›æ–‡ä»¶å"""
    try:
        # è·å–å¾…å¤„ç†æ–‡ä»¶ï¼ˆåªè·å–åŸºæœ¬ä¿¡æ¯ï¼Œä¸ç”Ÿæˆç¼©ç•¥å›¾ï¼?
        files = [f for f in os.listdir(SOURCE_DIR) if f.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp'))]
        pending_files = []
        
        for filename in files:
            path = os.path.join(SOURCE_DIR, filename)
            if os.path.exists(path):
                try:
                    # ä½¿ç”¨æ›´å¿«çš„æ–¹æ³•è·å–å›¾ç‰‡å°ºå¯?
                    img = cv2.imread(path)
                    if img is not None:
                        height, width = img.shape[:2]
                        file_size = os.path.getsize(path)
                        created_time = time.ctime(os.path.getctime(path))
                        
                        pending_files.append(ImageInfo(
                            filename=filename,
                            width=int(width),
                            height=int(height),
                            file_size=file_size,
                            created_time=created_time,
                            has_thumbnail=False,
                            thumbnail_url=None
                        ))
                except Exception as e:
                    print(f"Error processing file {filename}: {e}")
                    continue
        
        # è·å–å·²å¤„ç†æ–‡ä»?
        processed_files = [f for f in os.listdir(PROCESSED_DIR) if f.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp'))]
        
        # è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        total_files = len(pending_files) + len(processed_files)
        completion_rate = (len(processed_files) / total_files * 100) if total_files > 0 else 100
        
        return FileListResponse(
            pending_files=pending_files,
            processed_files=processed_files,
            total_files=total_files,
            completion_rate=completion_rate
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥: {str(e)}")

@app.get("/api/thumbnail/{filename:path}")
async def get_thumbnail(filename: str):
    """è·å–å›¾ç‰‡ç¼©ç•¥å›?""
    # URLè§£ç æ–‡ä»¶å?
    decoded_filename = urllib.parse.unquote(filename)
    
    thumbnail_path = get_thumbnail_path(decoded_filename, THUMBNAIL_DIR)
    
    if not os.path.exists(thumbnail_path):
        # å¦‚æœç¼©ç•¥å›¾ä¸å­˜åœ¨ï¼Œå°è¯•ç”Ÿæˆ?
        source_path = os.path.join(SOURCE_DIR, decoded_filename)
        if not os.path.exists(source_path):
            source_path = os.path.join(PROCESSED_DIR, decoded_filename)
        
        if os.path.exists(source_path):
            if not generate_thumbnail(source_path, thumbnail_path):
                raise HTTPException(status_code=404, detail="æ— æ³•ç”Ÿæˆç¼©ç•¥å›?)
        else:
            raise HTTPException(status_code=404, detail="åŸå›¾æ–‡ä»¶ä¸å­˜åœ?)
    
    return FileResponse(thumbnail_path, media_type="image/jpeg", headers={"Cache-Control": "max-age=3600"})


@app.post("/api/upload")
async def upload_files(files: List[UploadFile] = File(...)):
    """ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶"""
    uploaded_files = []
    errors = []
    
    for file in files:
        try:
            # éªŒè¯æ–‡ä»¶ç±»å‹
            if not file.content_type or not file.content_type.startswith('image/'):
                errors.append(f"{file.filename}: ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»?)
                continue
            
            # ä¿å­˜æ–‡ä»¶
            content = await file.read()
            file_path = os.path.join(SOURCE_DIR, file.filename)
            
            with open(file_path, "wb") as f:
                f.write(content)
            
            uploaded_files.append(file.filename)
            
        except Exception as e:
            errors.append(f"{file.filename}: {str(e)}")
    
    return {
        "uploaded_files": uploaded_files,
        "errors": errors,
        "success": len(uploaded_files) > 0
    }


@app.get("/api/image/{filename:path}")
async def get_image(filename: str):
    """æä¾›æºå›¾ç‰‡æ–‡ä»¶è®¿é—?""
    # URLè§£ç æ–‡ä»¶å?
    decoded_filename = urllib.parse.unquote(filename)
    
    # é¦–å…ˆå°è¯•ä»æºæ–‡ä»¶å¤¹æŸ¥æ‰?
    path = os.path.join(SOURCE_DIR, decoded_filename)
    if not os.path.exists(path):
        # å¦‚æœæºæ–‡ä»¶å¤¹æ²¡æœ‰ï¼Œå°è¯•ä»å¤„ç†æ–‡ä»¶å¤¹æŸ¥æ‰?
        path = os.path.join(PROCESSED_DIR, decoded_filename)
        if not os.path.exists(path):
            raise HTTPException(status_code=404, detail="å›¾ç‰‡æ–‡ä»¶ä¸å­˜åœ?)
    
    # æ£€æµ‹æ–‡ä»¶ç±»å?
    file_extension = decoded_filename.lower().split('.')[-1]
    media_type_map = {
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg', 
        'png': 'image/png',
        'bmp': 'image/bmp',
        'gif': 'image/gif'
    }
    media_type = media_type_map.get(file_extension, 'image/jpeg')
    
    return FileResponse(path, media_type=media_type, headers={"Cache-Control": "no-cache"})
@app.post("/api/preview/{filename:path}")
async def preview_crop(filename: str, request: CropRequest):
    """ç”Ÿæˆè£å‰ªé¢„è§ˆ"""
    # URLè§£ç æ–‡ä»¶å?

    decoded_filename = urllib.parse.unquote(filename)
    
    source_path = os.path.join(SOURCE_DIR, decoded_filename)
    if not os.path.exists(source_path):
        raise HTTPException(status_code=404, detail="æ–‡ä»¶ä¸å­˜åœ?)
    
    if not request.points or len(request.points) != 4:
        raise HTTPException(status_code=400, detail="éœ€è¦?ä¸ªè§’ç‚?)
    
    try:
        img = cv2.imread(source_path)
        if img is None:
            raise HTTPException(status_code=400, detail="æ— æ³•è¯»å–å›¾ç‰‡æ–‡ä»¶")
        
        height, width = img.shape[:2]
        print(f"ç”Ÿæˆé¢„è§ˆ: {filename}, å°ºå¯¸: {width}x{height}")
        print(f"è§’ç‚¹åæ ‡: {request.points}")
        
        # éªŒè¯å¹¶ä¿®æ­£è§’ç‚¹åæ ?
        corrected_points = validate_and_correct_points(request.points, width, height)
        
        # æ‰§è¡Œé€è§†å˜æ¢
        warped = four_point_transform(img, corrected_points)
        
        # å¦‚æœé¢„è§ˆå›¾ç‰‡å¤ªå¤§ï¼Œé€‚å½“ç¼©å°ä»¥ä¾¿åœ¨ç½‘é¡µä¸­æ˜¾ç¤º
        warped = resize_image_for_preview(warped)
        
        # ç¼–ç ä¸ºJPEGå¹¶è¿”å›?
        success, buf = encode_image_to_jpeg(warped, 90)
        if not success:
            raise HTTPException(status_code=500, detail="é¢„è§ˆå›¾ç‰‡ç¼–ç å¤±è´¥")
        
        return Response(content=buf.tobytes(), media_type="image/jpeg")
    
    except Exception as e:
        print(f"ç”Ÿæˆé¢„è§ˆæ—¶å‡ºé”? {str(e)}")
        raise HTTPException(status_code=500, detail=f"ç”Ÿæˆé¢„è§ˆæ—¶å‡ºé”? {str(e)}")


@app.post("/api/crop/{filename:path}", response_model=CropResponse)
async def crop(filename: str, request: CropRequest):
    """æ‰§è¡Œå›¾ç‰‡è£å‰ªå¹¶ç§»åŠ¨æ–‡ä»?""
    # URLè§£ç æ–‡ä»¶å?

    decoded_filename = urllib.parse.unquote(filename)
    
    source_path = os.path.join(SOURCE_DIR, decoded_filename)
    if not os.path.exists(source_path):
        raise HTTPException(status_code=404, detail="æ–‡ä»¶ä¸å­˜åœ?)
    
    if not request.points or len(request.points) != 4:
        return CropResponse(success=False, message="éœ€è¦?ä¸ªè§’ç‚?, error="Invalid points")
    
    try:
        img = cv2.imread(source_path)
        if img is None:
            return CropResponse(success=False, message="æ— æ³•è¯»å–å›¾ç‰‡æ–‡ä»¶", error="Cannot read image")
        
        height, width = img.shape[:2]
        print(f"å¤„ç†å›¾ç‰‡: {decoded_filename}, å°ºå¯¸: {width}x{height}")
        print(f"æ¥æ”¶åˆ°çš„è§’ç‚¹åæ ‡: {request.points}")
        
        # éªŒè¯å¹¶ä¿®æ­£è§’ç‚¹åæ ?
        corrected_points = validate_and_correct_points(request.points, width, height)
        print(f"ä¿®æ­£åçš„è§’ç‚¹åæ ‡: {corrected_points}")
        
        # æ‰§è¡Œé€è§†å˜æ¢
        warped = four_point_transform(img, corrected_points)
        
        # ç”Ÿæˆè¾“å‡ºæ–‡ä»¶å?
        name_without_ext = os.path.splitext(decoded_filename)[0]
        output_filename = f"{name_without_ext}_cropped.jpg"
        output_path = os.path.join(OUTPUT_DIR, output_filename)
        
        # ä¿å­˜è£å‰ªç»“æœ
        cv2.imwrite(output_path, warped)
        print(f"è£å‰ªç»“æœå·²ä¿å­˜åˆ°: {output_path}")
        
        # ç§»åŠ¨åŸæ–‡ä»¶åˆ°processedæ–‡ä»¶å¤?
        processed_path = os.path.join(PROCESSED_DIR, decoded_filename)
        
        # å¦‚æœprocessedæ–‡ä»¶å¤¹ä¸­å·²å­˜åœ¨åŒåæ–‡ä»¶ï¼Œæ·»åŠ æ—¶é—´æˆ?
        if os.path.exists(processed_path):
            timestamp = int(time.time())
            name_part, ext_part = os.path.splitext(decoded_filename)
            processed_filename = f"{name_part}_{timestamp}{ext_part}"
            processed_path = os.path.join(PROCESSED_DIR, processed_filename)
        
        # ç§»åŠ¨æ–‡ä»¶
        shutil.move(source_path, processed_path)
        
        return CropResponse(
            success=True,
            filename=output_filename,
            message="æ–‡ä»¶å·²å¤„ç†å®Œæˆå¹¶ç§»åŠ¨åˆ°processedæ–‡ä»¶å¤?,
            processed_filename=os.path.basename(processed_path)
        )
    except (IOError, ValueError, RuntimeError) as e:
        return CropResponse(success=False, message=f"å¤„ç†å¤±è´¥: {str(e)}", error=str(e))


@app.get("/api/download/{filename:path}")
async def download(filename: str):
    """ä¸‹è½½å¤„ç†åçš„å›¾ç‰‡"""
    # URLè§£ç æ–‡ä»¶å?

    decoded_filename = urllib.parse.unquote(filename)
    
    path = os.path.join(OUTPUT_DIR, decoded_filename)
    if not os.path.exists(path):
        raise HTTPException(status_code=404, detail=f"æ–‡ä»¶ä¸å­˜åœ? {decoded_filename}")
    
    return FileResponse(path, filename=decoded_filename)


@app.get("/api/image-info/{filename:path}", response_model=ImageInfo)
async def get_image_info(filename: str):
    """è¿”å›å›¾ç‰‡çš„å°ºå¯¸ä¿¡æ?""
    # URLè§£ç æ–‡ä»¶å?

    decoded_filename = urllib.parse.unquote(filename)
    
    path = os.path.join(SOURCE_DIR, decoded_filename)
    if not os.path.exists(path):
        raise HTTPException(status_code=404, detail=f"æ–‡ä»¶ä¸å­˜åœ? {decoded_filename}")
    
    try:
        img = cv2.imread(path)
        if img is None:
            raise HTTPException(status_code=400, detail="æ— æ³•è¯»å–å›¾ç‰‡æ–‡ä»¶")
        
        height, width = img.shape[:2]
        file_size = os.path.getsize(path)
        created_time = time.ctime(os.path.getctime(path))
        
        return ImageInfo(
            filename=filename,
            width=int(width),
            height=int(height),
            file_size=file_size,
            created_time=created_time
        )
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–å›¾ç‰‡ä¿¡æ¯æ—¶å‡ºé”? {str(e)}")


@app.post("/api/auto-detect/{filename:path}", response_model=AutoDetectResponse)
async def auto_detect_corners_api(filename: str):
    """è‡ªåŠ¨æ£€æµ‹å›¾ç‰‡çš„å››ä¸ªè§’ç‚¹"""
    # URLè§£ç æ–‡ä»¶å?

    decoded_filename = urllib.parse.unquote(filename)
    
    path = os.path.join(SOURCE_DIR, decoded_filename)
    if not os.path.exists(path):
        raise HTTPException(status_code=404, detail="æ–‡ä»¶ä¸å­˜åœ?)
    
    try:
        print(f"å¼€å§‹è‡ªåŠ¨æ£€æµ‹è§’ç‚? {filename}")
        
        # è°ƒç”¨è‡ªåŠ¨æ£€æµ‹å‡½æ•?
        corners, confidence = auto_detect_corners(path, debug=True)
        
        print(f"è‡ªåŠ¨æ£€æµ‹å®Œæˆ?- è§’ç‚¹: {corners}, ç½®ä¿¡åº? {confidence}")
        
        return AutoDetectResponse(
            success=True,
            corners=corners,
            confidence=float(confidence),
            message=f"è‡ªåŠ¨æ£€æµ‹å®Œæˆï¼Œç½®ä¿¡åº? {confidence:.1%}" if confidence > 0.3 else "æ£€æµ‹ç½®ä¿¡åº¦è¾ƒä½ï¼Œå»ºè®®æ‰‹åŠ¨è°ƒæ•?
        )
        
    except Exception as e:
        print(f"è‡ªåŠ¨æ£€æµ‹å¤±è´? {str(e)}")
        return AutoDetectResponse(
            success=False,
            corners=None,
            confidence=0.0,
            message="è‡ªåŠ¨æ£€æµ‹å¤±è´?,
            error=str(e)
        )


@app.get("/api/next-file/{current_filename:path}", response_model=NextFileResponse)
async def get_next_file(current_filename: str):
    """è·å–ä¸‹ä¸€ä¸ªå¾…å¤„ç†çš„å›¾ç‰‡æ–‡ä»¶å"""
    # URLè§£ç æ–‡ä»¶å?

    decoded_current_filename = urllib.parse.unquote(current_filename)
    
    try:
        files = [f for f in os.listdir(SOURCE_DIR) if f.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp'))]
        
        if not files:
            return NextFileResponse(
                success=False,
                next_filename=None,
                remaining_count=0,
                message="æ²¡æœ‰å¾…å¤„ç†çš„æ–‡ä»¶"
            )
        
        # å¦‚æœå½“å‰æ–‡ä»¶è¿˜åœ¨åˆ—è¡¨ä¸­ï¼ˆè¿™ç§æƒ…å†µä¸åº”è¯¥å‘ç”Ÿï¼Œå› ä¸ºè£å‰ªåæ–‡ä»¶å·²ç§»åŠ¨ï¼?
        if decoded_current_filename in files:
            files.remove(decoded_current_filename)
        
        if not files:
            return NextFileResponse(
                success=False,
                next_filename=None,
                remaining_count=0,
                message="æ‰€æœ‰æ–‡ä»¶å·²å¤„ç†å®Œæˆ"
            )
        
        # è¿”å›ç¬¬ä¸€ä¸ªæ–‡ä»¶ï¼ˆæŒ‰å­—æ¯é¡ºåºï¼‰
        next_file = sorted(files)[0]
        return NextFileResponse(
            success=True,
            next_filename=next_file,
            remaining_count=len(files),
            message="è·å–ä¸‹ä¸€ä¸ªæ–‡ä»¶æˆåŠ?
        )
        
    except Exception as e:
        return NextFileResponse(
            success=False,
            next_filename=None,
            remaining_count=0,
            message=f"è·å–ä¸‹ä¸€ä¸ªæ–‡ä»¶å¤±è´? {str(e)}"
        )


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
